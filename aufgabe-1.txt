**Was ist Speicherfragmentierung?**

Stell dir den Hauptspeicher (RAM) deines Computers wie einen grossen Schrank mit vielen Fächern vor. Programme (oder Teile davon) brauchen Platz in diesen Fächern, um zu laufen.

**Speicherfragmentierung** passiert, wenn dieser Speicherplatz (die Fächer) nicht mehr schön geordnet ist, sondern in viele kleine Stücke zerteilt ist. Auch wenn du insgesamt noch *genug freie* Stücke hast, sind sie so verteilt, dass du ein grosses Programm, das viel Platz *am Stück* braucht, nicht unterbringen kannst [91, Konversationshistorie].

Es gibt zwei Hauptarten dieser Zerteilung:

1.  **Externe Speicherfragmentierung:**
    *   **Was es ist:** Das ist, wenn der **freie Speicher** selbst in viele kleine, nicht zusammenhängende Lücken zerfallen ist. Die *Summe* aller freien Lücken reicht vielleicht aus, aber es gibt keine *einzelne, grosse* Lücke, die gross genug ist für eine neue Anforderung, die zusammenhängenden Speicher braucht.
    *   **Wie es passiert (Beispiel aus Quellen):** Wenn Programme in den Speicher geladen und wieder entfernt werden, entstehen Lücken verschiedener Grössen. Wenn ein grosses Programm entfernt wird und dann kleinere Programme an seiner Stelle geladen und wieder entfernt werden, bleibt nur noch eine Sammlung von kleinen Lücken übrig. Stell dir vor, dein Schrank hat ein grosses Fach, du nimmst etwas Grosses heraus, legst dann aber viele kleine Dinge einzeln in das Fach und nimmst sie wieder heraus – am Ende sind nur viele kleine leere Stellen da, kein grosses leeres Fach mehr.
    *   **Konkretes Beispiel (basierend auf Konversation/Quellenkontext):** Dein Hauptspeicher hat 100 MB frei, verteilt auf drei Lücken: 20 MB, 30 MB und 50 MB, mit belegten Bereichen dazwischen [basierend auf 17, 91 und Konversationshistorie]. Ein neues Programm braucht 60 MB **zusammenhängenden** Speicherplatz. Obwohl insgesamt 100 MB frei sind, gibt es keine einzelne Lücke von 60 MB. Das Programm kann nicht in den Speicher geladen werden, weil der freie Speicher **extern fragmentiert** ist. (Das Beispiel mit den verstreuten Parkplätzen, die nicht nebeneinander für einen grossen Bus reichen, passt auch gut hierzu [Konversationshistorie]).

2.  **Interne Speicherfragmentierung:**
    *   **Was es ist:** **(Diese spezifische Bezeichnung und Definition sind nicht direkt in den gegebenen Quellen, aber das Konzept ist relevant für Techniken wie Paging, die in den Quellen beschrieben werden):** Interne Fragmentierung passiert *innerhalb* eines Speicherbereichs, der einem Programm zugewiesen wurde. Wenn Speicher in festen Blockgrössen zugewiesen wird (z.B. immer in 4 KB grossen Stücken) [ähnlich dem Konzept der 'pages' bei Paging, 33], aber das Programm nur einen kleineren Teil dieses Blocks benötigt (z.B. 3 KB), bleibt der restliche Platz *innerhalb* dieses zugewiesenen Blocks (hier 1 KB) ungenutzt. Dieser ungenutzte Platz *innerhalb* eines belegten Blocks ist **interne Fragmentierung**.
    *   **Konkretes Beispiel:** Dein Betriebssystem weist Speicher in festen Einheiten von 4 KB zu (wie die "pages" bei Paging) [basierend auf 33]. Ein Programm braucht nur 3 KB für eine bestimmte Sache. Das Betriebssystem weist dem Programm einen vollen 4-KB-Block zu. Die restlichen 1 KB *in diesem Block* können nicht von anderen Programmen genutzt werden. Dieser ungenutzte 1 KB Platz *innerhalb* des zugewiesenen 4-KB-Blocks ist interne Fragmentierung.

**Strategien gegen Speicherfragmentierung**

Moderne Betriebssysteme haben clevere Methoden, um Fragmentierung zu verringern oder zu vermeiden. Die Quellen beschreiben zwei wichtige Ansätze:

1.  **Speicherverdichtung (Memory Compaction):**
    *   **Beschreibung:** Diese Strategie bekämpft die **externe Fragmentierung**. Stell dir vor, du schiebst alle belegten Speicherbereiche (die Programme) im Schrank ganz eng zusammen. Dadurch werden alle kleinen, freien Lücken zu einer oder wenigen grossen, zusammenhängenden Lücken vereint [17, basierend auf Konversationshistorie].
    *   **Vorteile:** Macht grosse, zusammenhängende Speicherbereiche wieder verfügbar, die vorher wegen der Fragmentierung nicht nutzbar waren.
    *   **Nachteile:** Kann ein **sehr aufwendiger Prozess** sein. Das Verschieben von Programmen im Speicher kostet viel Rechenzeit und kann das System verlangsamen oder kurz anhalten, während es passiert. Ausserdem ist es technisch komplex, weil das System sicherstellen muss, dass die verschobenen Programme danach immer noch wissen, wo sie jetzt im Speicher sind (Adressanpassung).

2.  **Virtueller Speicher (Paging):**
    *   **Beschreibung:** Dies ist ein moderner und sehr effektiver Ansatz. Anstatt ein Programm als einen grossen, zusammenhängenden Block zu sehen, wird es in viele kleine, gleich grosse Stücke, genannt **Seiten (pages)**, aufgeteilt. Der physische Hauptspeicher wird ebenfalls in gleich grosse Stücke, genannt **Seitenrahmen (page frames)**, unterteilt. Das Betriebssystem und spezielle Hardware (die MMU - Memory Management Unit) sorgen dafür, dass die Seiten eines Programms auf beliebige freie Seitenrahmen im physischen Speicher abgebildet werden können. Die Seiten eines Programms müssen **nicht nebeneinander** im physischen Speicher liegen.
    *   **Vorteile:**
        *   **Vermeidung externer Fragmentierung:** Da ein Programm keinen grossen, zusammenhängenden Block mehr braucht, sondern seine Seiten über verstreute freie Seitenrahmen verteilt werden können, wird die **externe Fragmentierung fast vollständig vermieden** [Implied by 28, 33]. Es reichen einzelne freie Seitenrahmen aus.
        *   **Ermöglicht Ausführung grosser Programme:** Programme können grösser sein als der gesamte physische Speicher, weil nicht alle Seiten gleichzeitig im Speicher sein müssen. Nicht benötigte Seiten können auf der Festplatte bleiben und werden nur bei Bedarf nachgeladen (Page Fault).
        *   **Unterstützt viele Programme gleichzeitig:** Viele Programme können laufen, auch wenn ihre Gesamtgrösse den physischen Speicher übersteigt.
    *   **Nachteile:**
        *   **Komplexität:** Benötigt spezielle Hardware (MMU) und ist sehr komplex für das Betriebssystem zu verwalten (es muss verfolgen, welche Seite jedes Programms wo liegt, über Seitentabellen).
        *   **Leistungseinbussen bei Page Faults:** Wenn das Programm auf eine Seite zugreift, die gerade nicht im Hauptspeicher ist ("Page Fault"), muss diese Seite erst von der langsameren Festplatte nachgeladen werden. Das kann zu spürbaren Verzögerungen führen.
        *   **Ressourcenverbrauch:** Die Tabellen, die das Betriebssystem braucht, um zu wissen, welche virtuelle Seite auf welchen physischen Seitenrahmen abgebildet ist (Seitentabellen), brauchen selbst Speicherplatz [Implied by 40, 41].
        *   **Interne Fragmentierung (Konsequenz, nicht direkt aus Quellen):** Da die Seiten eine feste Grösse haben, kann es – wie oben beschrieben – zu ungenutztem Platz *innerhalb* der letzten Seite eines Programms oder Datenbereichs kommen, wenn dieser nicht genau die volle Seitengrösse ausfüllt.
