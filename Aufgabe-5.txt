# Beschreiben Sie die Ausgabe des Programms. Was sagt sie über die Organisation des Speichers in Ihrem Betriebssystem aus?
Die Ausgabe „Stack wächst nach oben“ zeigt, dass bei deinem System lokale Variablen mit steigenden Adressen im Stack abgelegt werden – eine eher ungewöhnliche, aber mögliche Speicherorganisation.
Die Adressdifferenz im Heap: -32 bedeutet, dass der zweite malloc()-Block unterhalb des ersten im Speicher liegt. Das deutet darauf hin, dass der Heap in deinem System nach unten wächst, also zu niedrigeren Adressen.

# Was sagt das über die Speicherorganisation aus?
Das (verwendete) Betriebssystem oder die Architektur verwendet ein nicht-standardmäßiges Speicherlayout, bei dem der Stack nach oben wächst – also zu höheren Adressen – und der Heap nach unten, in Richtung niedrigerer Adressen. Dieses Verhalten weicht vom üblichen Modell ab, bei dem der Stack nach unten und der Heap nach oben wächst, ist jedoch technisch gültig und abhängig von der Prozessorarchitektur sowie der Konfiguration des Betriebssystems.

# --------------------------------

# Warum liegen Stack-, Heap- und statische Variablen in getrennten Speicherbereichen?

Jeder Bereich hat unterschiedliche Anforderungen:
Stack: automatische, kurzlebige Variablen mit schnellem Zugriff (Funktionsein-/-ausstieg).
Heap: dynamisch verwalteter Speicher mit flexibler Lebensdauer.
Statische Daten: fix im Speicher, bekannt zur Kompilierzeit.

Durch die Trennung kann das Betriebssystem:
Speicher effizient verwalten. 
Überläufe und Kollisionen verhindern. 
Schutzmechanismen wie Zugriffskontrollen einsetzen.

# --------------------------------

# Welche Auswirkungen hat das absichtlich erzeugte Speicherleck? Wie könnte ein Betriebssystem mit solchen Situationen umgehen?

# Auswirkungen des Speicherlecks
Das absichtlich nicht freigegebene malloc(100) führt zu einem Speicherleck, da der reservierte Speicher nicht zurückgegeben wird. Tritt dieses Verhalten häufiger auf, kann es zu einem stetig steigenden RAM-Verbrauch kommen, was das System verlangsamt und im Extremfall sogar zu einem Absturz durch Speichermangel führen kann.

# Wie geht das Betriebssystem damit um?
Nach Beenden eines Prozesses gibt das Betriebssystem den belegten Speicher in der Regel automatisch frei. Während der Laufzeit jedoch wird ein Speicherleck nicht automatisch erkannt – hierfür werden spezielle Werkzeuge wie valgrind oder AddressSanitizer benötigt. In sicherheitskritischen Systemen kommen zusätzlich Überwachungsmechanismen zum Einsatz, um Speicherlecks frühzeitig zu erkennen und deren Auswirkungen zu begrenzen.


