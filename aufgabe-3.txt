Ein Speicherleck (Memory Leak) passiert, wenn ein Programm Speicher reserviert (z.â€¯B. mit malloc()), aber nicht wieder freigibt (free() fehlt).

    ğŸ“‰ Auswirkungen:

        Der Speicher bleibt blockiert, obwohl er nicht mehr gebraucht wird.

        Bei langen Programmen oder vielen Lecks kann der Speicher ausgehen.

        Das Programm wird langsam oder stÃ¼rzt ab.

    ğŸ§  Was macht das Betriebssystem?

        Das OS kann den gesamten Speicher beim Programmende zurÃ¼ckholen.

        WÃ¤hrend der Laufzeit merkt das OS das Leak nicht sofort.

        Tools wie Valgrind helfen, Lecks zu finden.

Teil 1: ErklÃ¤rung der Befehle

mkdir -p test/subdir && cd test

Erstellt einen Ordner â€testâ€œ mit Unterordner â€subdirâ€œ und wechselt in den Ordner â€testâ€œ.

echo "Inhalt-$(date +%s)" > original.txt

Erstellt die Datei original.txt mit aktuellem Zeitwert als Inhalt.

ln -s original.txt symlink.txt

Erstellt einen symbolischen Link (Pfadverweis) auf original.txt.

ln original.txt hardlink.txt

Erstellt einen Hardlink â€“ eine zweite Referenz zur gleichen Datei (gleiche Inode).

chmod 640 original.txt

Setzt die Dateiberechtigung:

    EigentÃ¼mer darf lesen & schreiben,

    Gruppe darf lesen,

    Andere nichts.

touch -d "2 days ago" original.txt

Ã„ndert den Zeitstempel (Ã„nderungsdatum) auf vor 2 Tagen.

ls -la

Zeigt eine detaillierte Liste aller Dateien mit Inodes, Berechtigungen, Zeitstempeln usw.

Teil 2: Analyse der Ausgabe ls -la
Bedeutung der Spalten:

    Berechtigungen (z.â€¯B. -rw-r-----)

    Anzahl der Hardlinks

    Benutzer

    Gruppe

    DateigrÃ¶ÃŸe

    Zeitstempel der letzten Ã„nderung

    Dateiname

Unterschiede:

    original.txt und hardlink.txt haben gleiche Inode, weil sie denselben Inhalt teilen.

    symlink.txt hat einen eigenen Inode, verweist nur auf original.txt.

    Zeitstempel ist bei symlink.txt meist der Erstellzeitpunkt des Links, nicht der Zieldatei.
    
     Teil 3: Weitere Befehle

echo "Neuer Inhalt" > original.txt

Ãœberschreibt den Inhalt der Datei. Da hardlink.txt dieselbe Inode hat, sieht man dort denselben neuen Inhalt.

cat symlink.txt hardlink.txt

Gibt den Inhalt der Datei zweimal aus. Beide zeigen auf dieselben Daten.

mv original.txt ../original.txt

Verschiebt original.txt in das Ã¼bergeordnete Verzeichnis.
â†’ symlink.txt ist jetzt â€brokenâ€œ, weil der Pfad nicht mehr gÃ¼ltig ist.
â†’ hardlink.txt bleibt funktionierend (gleiche Inode).

cat symlink.txt hardlink.txt 2>&1

    hardlink.txt: zeigt den Inhalt.

    symlink.txt: Fehler, da Datei nicht mehr existiert â†’ â€No such file or directoryâ€œ.

ğŸ“Œ Auswirkungen auf die Inode-Tabelle:

    Der Hardlink behÃ¤lt die Inode.

    Der Symbolische Link hat eigene Inode und verweist nur.

    Beim mv wird der Inode von original.txt nicht gelÃ¶scht, weil hardlink.txt noch existiert.


