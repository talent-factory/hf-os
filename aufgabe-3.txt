Wir beginnen mit dem Befehl mkdir -p test/subdir && cd test. Zuerst weist die Shell mkdir an, das Verzeichnis test und darunter den Ordner subdir anzulegen; dank der Option -p werden fehlende Elternverzeichnisse automatisch erzeugt und ein eventuell schon vorhandenes Verzeichnis fuehrt nicht zu einem Fehler. Jeder Ordner bekommt dabei einen eigenen Inode, in dem Rechte und Metadaten gespeichert werden, waehrend der Verzeichniseintrag selbst lediglich den Namen mit dieser Inode‑Nummer verknuepft. Das doppelte kaufmaennische Und (&&) prueft den Rueckgabewert von mkdir; nur wenn der Exit‑Status 0 ist, wird der zweite Teil ausgefuehrt. Mit cd test setzt die Shell das aktuelle Arbeitsverzeichnis auf test, sodass alle relativen Pfade der folgenden Befehle von dort aus aufgeloest werden.

Als Naechstes fuegen wir mit
echo "Inhalt-$(date +%s)" > original.txt
eine Datei hinzu. Zunaechst ersetzt die Shell in $(date +%s) die Kommandoeinbettung durch die aktuelle Unix‑Zeit in Sekunden, so dass beispielhaft der Text Inhalt‑1715323742 entsteht. echo schreibt diesen String auf den Standardausgabekanal; die Umleitung > oeffnet (oder legt an) die Datei original.txt, leert sie gegebenenfalls (O_TRUNC) und schreibt den Datenstrom hinein. Dabei entstehen eine neue Inode für die Datei, der erste Verzeichniseintrag und Anfangsrechte gemaess der Umask.

Mit ln -s original.txt symlink.txt erzeugen wir dann einen symbolischen Link. Dieser Befehl legt einen eigenen Inode an, dessen Datenbereich bloss den Pfad original.txt enthaelt. Wird spaeter auf symlink.txt zugegriffen, folgt der Kernel diesem Pfad und oeffnet das Ziel, was auch über Dateisystemgrenzen hinweg funktioniert, da lediglich der String gespeichert ist. Der Link erhoeht nicht den Linkcount des Zielinodes.

Demgegenueber bewirkt ln original.txt hardlink.txt einen Hardlink. Hier legt das Dateisystem nur einen zusaetzlichen Verzeichniseintrag an, der auf genau dieselbe Inode zeigt wie original.txt. Weil nun zwei Namen auf dieses Objekt verweisen, steigt der Linkcount in der Inode von 1 auf 2. Ob man die Datei spaeter als original.txt oder hardlink.txt oeffnet, macht keinen Unterschied – beide Namen adressieren dasselbe Datenobjekt. Weil Hardlinks auf Inoden arbeiten, sind sie auf dasselbe physische Dateisystem beschraenkt.

Mit chmod 640 original.txt werden die Zugriffsrechte dieses Inodes angepasst. Die Oktalzahl 640 setzt Les‑ und Schreibrecht fuer den Besitzer (6), Leserecht fuer die Gruppe (4) und keinerlei Rechte fuer alle anderen (0). Weil Rechte an der Inode gespeichert sind, gilt diese Aenderung automatisch fuer alle Hardlinks; der symbolische Link bleibt unbeeinflusst, und wuerde man direkt auf ihn chmod anwenden, gaebe es je nach Betriebssystem unterschiedliche Regeln, die man mit chmod -h explizit steuern kann.

Anschliessend ruft touch -d "2 days ago" original.txt den Befehl touch auf, der normalerweise die Dateizeitstempel auf die Gegenwart setzt. Dank der Option -d stellen wir jedoch eine beliebige Uhrzeit ein; hier werden mtime (Modifikationszeit) und, sofern nicht anders konfiguriert, auch atime auf „vor zwei Tagen“ zurueckdatiert. Dabei aktualisiert der Kernel automatisch ctime (Change Time) auf die aktuelle Sekunde, weil das reine Veraendern von Metadaten selbst als Aenderung gilt. Auch diese Zeitwerte liegen in der gemeinsamen Inode und betreffen somit beide Hardlinks, waehrend der Symlink seine eigenen Anlagezeiten behaelt.

Zum Schluss zeigt ls -la im Langformat alle Eintraege, auch versteckte. Man erkennt an der ersten Spalte den Typ (d fuer Verzeichnis, - fuer regulaere Datei, l fuer Symlink), unmittelbar daneben die aktuellen Rechte, danach den Linkcount, Besitzer, Gruppe, Groesse, Datum und Dateinamen. Fuer original.txt und hardlink.txt steht im Linkcount die 2, was bestaetigt, dass beide denselben Inode teilen. Beide weisen dieselbe Groesse und denselben auf „vor zwei Tagen“ gesetzten Zeitstempel auf. Beim Eintrag zu symlink.txt sieht man den Pfeil -> original.txt; die Datei ist nur so lang wie dieser Pfadstring und traegt einen Linkcount von 1, weil Symlinks nicht zaehlend auf den Zielinode wirken.

Alle Befehle illustrieren zentrale Dateisystemprinzipien: Verzeichnisse sind Mappings von Namen zu Inoden; mehrere Namen koennen mittels Hardlink auf denselben Inode zeigen, waehrend ein Symlink bloss einen Pfad speichert. Rechte und Zeitstempel werden in der Inode verwaltet und sind damit fuer alle Hardlinks identisch. Umleitung und Befehle wie touch oder chmod agieren immer auf Inoden, unabhaengig davon, unter welchem Namen man sie anspricht. So zeigt die kleine Befehlssequenz, wie POSIX‑Dateisysteme Hierarchie, Links, Metadaten und Shell‑Mechanismen zusammenfuehren.

Ausgabe:
➜  test git:(hfi2024c/dennis-scapoli) ✗ ls -la
insgesamt 20
drwxrwxr-x 3 vmadmin vmadmin 4096 Mai 10 08:29 .
drwxr-xr-x 4 vmadmin vmadmin 4096 Mai 10 08:28 ..
-rw-r----- 2 vmadmin vmadmin   18 Mai  8 08:29 hardlink.txt
-rw-r----- 2 vmadmin vmadmin   18 Mai  8 08:29 original.txt
drwxrwxr-x 2 vmadmin vmadmin 4096 Mai 10 08:28 subdir
lrwxrwxrwx 1 vmadmin vmadmin   12 Mai 10 08:29 symlink.txt -> original.txt

Die Langform‑Ausgabe von ls ‑la hat stets denselben Aufbau: Ganz links steht das Dateiattributfeld. Das erste Zeichen kennzeichnet den Typ – ein Bindestrich zeigt eine normale Datei, ein ­d würde ein Verzeichnis, ein ­l einen symbolischen Link anzeigen. Es folgen neun Zeichen für die Zugriffsrechte: je drei Bits für Besitzer, Gruppe und «Others», in der Reihenfolge Lesen (r), Schreiben (w) und Ausführen (x). Danach erscheint die Zahl des Link‑Counts, also wie viele Verzeichniseintraege auf genau dieselbe Inode verweisen. Es folgen Besitzer‑ und Gruppennamen, anschliessend die Groesse in Byte. Danach gibt das Datum den letzten Inhaltsaenderungszeitpunkt wieder (mtime) – bei Dateien, die vor weniger als sechs Monaten geaendert wurden, inklusive Uhrzeit, sonst mit Jahr. Zuletzt steht der Name des Verzeichniseintrags; bei symbolischen Links zeigt ein Pfeil «->» auf das als Text gespeicherte Ziel.

Sowohl original.txt als auch hardlink.txt haben denselben Typ «-», identische Rechte «rw‑r-----» (das entspricht oktal 640), identische Groesse von 18 Byte und – entscheidend – einen Link‑Count von 2. Das bedeutet, beide Namen verweisen auf dieselbe Inode; sie sind Hardlinks desselben Datenobjekts. Darum tragen sie auch exakt denselben mtime, hier «8. Mai 08:29», weil wir ihn zuvor mit touch -d "2 days ago" auf dieses Datum gesetzt haben. Wird eine der beiden Dateien geloescht, bleibt der Inhalt so lange erhalten, bis auch der zweite Name entfernt ist und der Link‑Count auf 0 faellt.

symlink.txt dagegen beginnt mit «l» und weist damit aus, dass es sich um einen symbolischen Link handelt. Sein Rechtefeld lautet systembedingt «rwxrwxrwx»; diese Bits werden in den meisten Faellen ignoriert, weil der Kernel beim Zugriff sofort das Ziel followt. Der Link‑Count steht auf 1, denn dieser Symlink hat einen eigenen Inode, der lediglich den Pfadstring «original.txt» enthaelt; er vergroessert den Link‑Count der Zieldatei nicht. Seine Groesse von 12 Byte ist genau die Laenge dieses gespeicherten Pfades. Der Zeitstempel «10. Mai 08:29» zeigt das Anlagedatum des Links selbst und aendert sich nicht, wenn wir spaeter den Inhalt von original.txt anpassen.

Warum also teilen manche Dateien ihre Inode‑Nummer und andere nicht? Ein Hardlink ist nur ein zweiter Verzeichniseintrag fuer ein und dieselbe Inode; Inhalte und Metadaten liegen gemeinsam vor, weshalb alle Hardlinks dieselbe Inode‑Nummer, denselben Link‑Count und identische Zeitstempel haben. Ein symbolischer Link hingegen ist ein eigenstaendiges Dateisystemobjekt mit eigener Inode, das nur einen Wegweiser auf einen beliebigen Pfad speichert. Darum besitzt er immer eine andere Inode‑Nummer, abweichende Groesse und seine eigenen Metadaten.

Nachdem wir nun „Neuer Inhalt“ mit echo "Neuer Inhalt" > original.txt in die Datei geschrieben haben, oeffnet die Shell den gemeinsamen Inode von original.txt und hardlink.txt im Truncate‑Modus, leert ihn und schreibt den neuen Text samt Zeilenumbruch hinein. Dabei aendern sich mtime und ctime dieses einzelnen Inodes und seine Groesse schrumpft auf dreizehn Byte; der Link‑Count bleibt zwei, weil beide Verzeichniseintraege nach wie vor existieren. symlink.txt wird dabei nicht beruehrt, denn der Link enthaelt nur den Pfadstring und verweist nicht direkt auf den Inode.

Mit cat symlink.txt hardlink.txt folgt der Kernel beim ersten Namen dem Symlink, findet im gleichen Verzeichnis den Eintrag original.txt, oeffnet dadurch denselben Inode und gibt den frischen Text „Neuer Inhalt“ aus. Anschliessend liest cat via Hardlink erneut den exakt gleichen Inode und wiederholt damit wortgleich die Ausgabe; wir sehen also zwei identische Zeilen, was zeigt, dass Hard‑ und Symlink in diesem Moment noch beide zum selben Datenobjekt fuehren.

Das Kommando mv original.txt ../original.txt verschiebt danach lediglich den Verzeichniseintrag: auf Dateisystemebene erfolgt bloss ein rename(), weil Quell‑ und Zielverzeichnis auf derselben Partition liegen. Der Inode selbst bleibt unangetastet, Link‑Count und Datenbloecke bleiben gleich; doch im Verzeichnis test gibt es nun keinen Namen original.txt mehr. Fuer Hardlinks ist das egal, denn hardlink.txt zeigt weiterhin direkt auf den Inode. Der Symlink hingegen speichert unveraendert den relativen Pfad „original.txt“ und wird damit unbrauchbar: seine Wegbeschreibung laesst sich im aktuellen Verzeichnis nicht mehr aufloesen.

Genau das demonstriert cat symlink.txt hardlink.txt 2>&1. Beim Versuch, den Symlink zu oeffnen, erhaelt der Kernel nun den Fehler ENOENT, weil der gespeicherte Pfad kein Ziel mehr findet; cat gibt daher eine Fehlermeldung auf stderr aus, die wir dank der Umleitung 2>&1 gemeinsam mit stdout sehen. Danach verarbeitet cat den Hardlink, oeffnet erfolgreich den Inode und liefert erneut „Neuer Inhalt“. Wiederholen wir denselben Befehl spaeter, bleibt das Verhalten identisch: der Symlink bleibt ein „broken link“, solange wir ihn nicht anpassen oder im Verzeichnis test wieder einen Eintrag namens original.txt anlegen.

In der Inode‑Tabelle hat sich also Folgendes ergeben: der gemeinsame Inode der beiden echten Dateien traegt weiter zwei Links, allerdings heisst der eine nun ../original.txt, der andere test/hardlink.txt. Der Symlink besitzt nach wie vor seinen eigenen Inode, Link‑Count eins, zeigt aber ins Leere. Wuerden wir jetzt hardlink.txt loeschen, fiele der Link‑Count des Dateninodes auf eins; loeschen wir anschliessend das nach oben verschobene ../original.txt, erst dann wuerden Datenbloecke freigegeben. Der Symlink waere schon vorher defekt und wuerde auch nach dem Loeschvorgang nur noch auf einen nicht mehr existierenden Pfad zeigen.

Moegliche Fehler koennen an ganz unterschiedlichen Stellen auftreten: haetten wir beim Verschieben kein Schreibrecht im Zielverzeichnis gehabt, waere mv mit „Permission denied“ gescheitert; laegen Quell‑ und Zielverzeichnis auf verschiedenen Dateisystemen, wuerde mv im Hintergrund kopieren und anschliessend loeschen, was dem Hardlink seinen gemeinsamen Inode entziehen und ihn damit selbst dangling machen koennte. Auch der Symlink koennte anstelle von ENOENT einen „permission denied“‑Fehler bringen, wenn der Benutzer zwar den Link, aber nicht den Zielpfad durchqueren darf. Das eigentliche Kernverhalten bleibt jedoch gleich: Hardlinks binden fest an den Inode, waehrend Symlinks einen Pfad hinterlegen, der bei jeder Namensaenderung oder Verschiebung des Ziels leicht zerbricht.

Sobald Quelle und Ziel in verschiedenen Dateisystemen liegen, verschieben wir uns über eine sogenannte Geraetegrenze, und damit aendert sich das Verhalten deutlich. Ein Hardlink laesst sich dann gar nicht erst anlegen: der Kernel kann einen einzigen Inode nur innerhalb seines eigenen Nummernraums verwalten, also innerhalb derselben Partition. Ruft man in dieser Situation einfach ln original.txt hardlink.txt auf, bricht der Befehl sofort mit dem Fehler „invalid cross‑device link“ ab und erzeugt gar nichts. Ein symbolischer Link haette dieses Problem nicht, weil er lediglich einen Pfadstring speichert; ob das Ziel auf derselben oder auf einer anderen Partition liegt, spielt fuer einen Symlink keine Rolle.

Auch ein spaeteres mv original.txt ../original.txt funktioniert nun nicht mehr als reines Umhaengen des Verzeichniseintrags. Da rename() eine Datei nur innerhalb desselben Devices verschieben darf, faellt das Kommando automatisch in den Modus Kopieren‑und‑Loeschen: zuerst schreibt es den gesamten Inhalt der Datei auf Partition B und legt dort einen neuen Inode mit neuem ctime an, anschliessend entfernt es den alten Verzeichniseintrag aus Partition A. Das bedeutet, dass der Inode, auf den ein eventuell vorhandener Hardlink in Partition A zeigt, unveraendert weiterexistiert, waehrend die kopierte Datei in Partition B ihren eigenen, voellig unabhaengigen Inode besitzt. Ab diesem Zeitpunkt koennen sich die Inhalte der beiden Objekte divergieren, sobald man eines der beiden separat bearbeitet.

Bonus Frage:
Der symbolische Link verhaelt sich dagegen ebenso wie im Ein‑Dateisystem‑Fall, allerdings nur, wenn er einen relativen Pfad enthaelt. Ein Pfad wie „original.txt“ verweist weiterhin in das Verzeichnis test der Quelle und findet dort nach dem Kopiervorgang nichts mehr, sodass jeder Zugriff mit ENOENT endet. Haette man statt dessen beim Anlegen des Symlinks einen absoluten Pfad auf die Datei benutzt, wiese er jetzt korrekt auf das Ziel in Partition B und bliebe voll funktionsfaehig. Ausserdem treten neue Fehlerquellen auf: Beim Kopieren koennte auf Partition B der Speicherplatz fehlen, Rechteattribute koennten nicht übernommen werden oder eine inkompatible Dateisystemart (etwa FAT statt ext4) koennte den Posix‑Rechtestatus abschneiden. In all diesen Faellen bricht mv mit einer Fehlermeldung ab, waehrend der alte Inode in Partition A erhalten bleibt. Letztlich beschraenkt eine Geraetegrenze Hardlinks strikt auf eine Partition, zwingt mv zum Kopieren und loeschen und setzt Symlinks dem Risiko aus, ins Leere zu zeigen, falls ihr gespeicherter Pfad nach dem Umzug nicht mehr aufgeloest werden kann.
