5.1. Speichervisualisierung und Adressraumanalyse

1. Beschreiben Sie die Ausgabe des Programms. Was sagt sie über die Organisation des Speichers in Ihrem Betriebssystem aus?
Die Ausgabe zeigt deutlich die Speicherorganisation in deinem Linux-Betriebssystem:

Adressbereiche:
Stack: 0x7ffc03929540 (sehr hohe Adresse)
Heap: 0x56ca690b42a0 (mittlere Adresse)
Statische Variable: 0x56ca67177010 (niedrigere Adresse als Heap)


Adressdifferenzen:
Die riesige Differenz zwischen Stack und anderen Bereichen (45+ Milliarden Bytes) zeigt, dass der Stack komplett getrennt vom Rest des Speicherbereichs liegt.
Die Differenz zwischen Heap und statischem Bereich beträgt ~32 MB, was einen typischen Abstand dieser Segmente darstellt.


Wachstumsrichtungen:
Entgegen der üblichen Erwartung zeigt das Programm, dass der Stack auf diesem System nach oben wächst (von niedrigen zu hohen Adressen). Dies ist interessant, da klassische x86-Architekturen normalerweise einen nach unten wachsenden Stack haben. Möglicherweise handelt es sich um einen Compiler-Optimierungseffekt bei lokalen Variablen oder eine architekturspezifische Eigenschaft.


Heap-Allokationen:
Die fünf absichtlich erzeugten Speicherlecks zeigen eine kontinuierliche Adresszunahme (jeweils um 4112 Bytes), was bestätigt, dass der Heap nach oben wächst.



2. Erklären Sie, warum die Adressen der verschiedenen Variablentypen (Stack, Heap, statisch) in unterschiedlichen Speicherbereichen liegen.
Die verschiedenen Variablentypen befinden sich aus folgenden Gründen in unterschiedlichen Speicherbereichen:

Statische Variablen (0x56ca67177010):
Werden im Datensegment des Programms gespeichert
Existieren während der gesamten Programmausführung
Werden beim Programmstart initialisiert
Der Speicherplatz wird schon beim Kompilieren/Linken festgelegt
Liegen in niedrigeren Adressbereichen nahe dem Code-Segment


Heap-Variablen (0x56ca690b42a0):
Werden dynamisch zur Laufzeit mit malloc() allokiert
Haben eine flexible Lebensdauer, die durch free() beendet werden kann
Der Heap wächst nach Bedarf und muss effizient fragmentierten Speicher verwalten
Liegen in mittleren Adressbereichen mit Platz zum Wachsen


Stack-Variablen (0x7ffc03929540):
Automatische Lebensdauer, gebunden an den Funktionsaufruf
Schnelle Allokation und Deallokation durch einfaches Verschieben eines Stack-Pointers
Unterstützt die Verwaltung von Funktionsaufrufen und deren lokalen Variablen
Liegt in sehr hohen Adressbereichen, weit entfernt von anderen Segmenten



Diese Trennung bietet mehrere Vorteile:
Unterschiedliche Optimierungsmöglichkeiten für jeden Bereich
Schutz vor Überschreibungen zwischen verschiedenen Speicherarten
Effizienzsteigerung durch passende Zugriffsmuster
Unterstützung verschiedener Lebensdauerkonzepte in der Programmierung

3. Welche Auswirkungen hat das absichtlich erzeugte Speicherleck? Wie könnte ein Betriebssystem mit solchen Situationen umgehen?
Auswirkungen des Speicherlecks:

Nicht freigegebener Speicher bleibt über die Programmausführung hinaus belegt
Bei längerer Laufzeit oder häufigeren Allokationen würde sich der verfügbare Speicher kontinuierlich verringern
In der Ausgabe sehen wir 5 Allokationen von je 1024×4 Bytes (4KB), die nicht freigegeben werden
Bei umfangreichen oder langlebigen Anwendungen kann dies zu Speichererschöpfung führen
Systemressourcen werden ineffizient genutzt und verschwendet

Massnahmen des Betriebssystems zur Bewältigung:

Prozessbeendigung als Grundschutz:
Bei Programmende gibt das Betriebssystem automatisch allen vom Prozess belegten Speicher frei
Dies ist die grundlegendste Schutzmaßnahme gegen dauerhafte Speicherverluste


Speichermanagement während der Laufzeit:
Virtuelle Speicherverwaltung mit Paging ermöglicht das Auslagern ungenutzter Seiten
Speicherüberwachung kann Anomalien im Speicherverbrauch erkennen


Ressourcenbegrenzungen:
Limits für maximalen Speicherverbrauch pro Prozess (z.B. via ulimit in Linux)
Priorisierung kritischer Prozesse im Ressourcenmanagement


Out-of-Memory (OOM) Management:
Der Linux OOM-Killer beendet Prozesse mit übermäßigem Speicherverbrauch
Bewertung der Prozesse nach "Schädlichkeit" und Wichtigkeit


Fortgeschrittene Techniken:
Heap-Profiler und Memory-Leak-Detektoren wie Valgrind
Container-Technologien isolieren Ressourcenverbrauch zwischen Anwendungen
Moderne Programmiersprachen mit automatischer Speicherbereinigung (Garbage Collection)
