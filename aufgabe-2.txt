In der Praxis spricht man von interner Fragmentierung, wenn einem Prozess ein fester Speicherblock zugeteilt wird, dessen Groesse seine tatsaechlich benoetigte Nutzlast ueberschreitet. Die Differenz bleibt ungenutzt, geht aber dennoch als belegt in die Buchfuehrung ein. Ein gaengiges Beispiel liefert die Seiteneinteilung in einem typischen Desktop‑Betriebssystem: Fordert eine Anwendung für ihren Stack 3,3 KiB an, erhaelt sie die gesamte 4‑KiB‑Seite; die verbleibenden 0,7 KiB sind zwar physisch vorhanden, koennen aber niemand anderem zugewiesen werden. Externe Fragmentierung entsteht dagegen, wenn sich im Verlauf vieler Allokationen und Freigaben der freie Speicher in zahlreiche kleine, nicht zusammenhaengende Luecken aufsplittert. Obwohl ihre Summe oft gross genug waere, laesst sich daraus kein groesserer zusammenhaengender Block mehr bilden. So kann ein Embedded‑System nach laengerer Laufzeit zehn über den RAM verstreute 4‑KiB‑Luecken besitzen, aber dennoch scheitert ein Treiber, der einmalig 32 KiB contiguous DMA‑Speicher benoetigt.

Moderne Betriebssysteme setzen mehrere Mechanismen ein, um diese beiden Fragmentierungsarten zu mildern. Das grundlegende Instrument ist das Paging: Saemtlicher Arbeitsspeicher wird in gleich grosse Seiten zerlegt, und die Memory‑Management‑Unit stellt eine virtuelle Adresse einem beliebigen physischen Frame zu. Dadurch verschwindet externe Fragmentierung praktisch vollstaendig, weil jeder Seitenrahmen an eine andere Stelle im RAM gemappt werden darf. Allerdings produziert Paging interne Fragmentierung innerhalb der letzten Seite jeder Zuordnung, und es erzeugt Verwaltungsaufwand in Form von Seitentabellen und TLB‑Eintraegen – je kleiner die Seiten, desto geringer der Verschnitt, aber desto groesser die Tabellendichte und der TLB‑Druck. Um die verbleibenden Defizite weiter zu verringern, verknuepfen Kernel wie Linux ein Buddy‑System mit Slab‑ oder SLUB‑Allocator und einem Hintergrund‑Compaction‑Daemon. Der Buddy‑Allocator haelt den physischen Speicher in 2‑Potenz‑Bloecken vor und teilt bei Bedarf einen groesseren Block in zwei haelfte, bis die naechstpassende Groesse gefunden ist; fuer Kleinstobjekte wie Inode‑Strukturen benutzt der Slab‑Layer diese Bloecke als Pools, aus denen gleichartige Objekte auf Cache‑freundliche Weise gezogen werden. Um dennoch auftretende externe Fragmentierung wieder einzufangen, verschiebt die Compaction‑Routine im Leerlauf Seiten, die sich nahtlos migrieren lassen, wodurch groessere zusammenhaengende Buddy‑Bloecke erneut frei werden. Das Trio senkt die interne Fragmentierung, ermoeglicht im Bedarfsfall contiguous Speicher und sorgt dank vorbereiteter Freilisten fuer sehr schnelle Allokationen. Dem stehen allerdings eine deutlich hoehere Implementierungskomplexitaet, Zusatzmetadaten und gelegentliche CPU‑Lastspitzen gegenueber, wenn Compaction Seiten verschiebt oder auslagern muss. Insgesamt gilt: Paging liefert das robuste Grundgeruest gegen externe Fragmentierung, waehrend Buddy, Slab und Compaction den Speicherfeinschliff besorgen, indem sie den internen Verschnitt minimieren und grosse physische Bereiche auf Abruf wiederherstellen – allerdings um den Preis von zusaetzlichem Code, Speicherverwaltung und Rechenzeit.
