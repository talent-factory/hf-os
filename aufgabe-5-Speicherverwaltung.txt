5.1. Speichervisualisierung und Adressraumanalyse

Ausgabe vom Code:

Speicheradressanalyse:
---------------------
Stack-Variable: 0x7ffde8864a00
Heap-Variable: 0x58d81294e2a0
Statische Variable: 0x58d811a27010

Adressdifferenzen:
Stack zu Heap: 43043456640864 Bytes
Stack zu Statisch: 43043472529904 Bytes
Heap zu Statisch: 15889040 Bytes

Wachstumsrichtungen:
Stack-Variable 1: 0x7ffde88649c8
Stack-Variable 2: 0x7ffde88649cc
Der Stack wächst nach oben (von niedrigen zu hohen Adressen)

Erzeuge absichtlich Speicherlecks:
Speicherleck 0 erzeugt an Adresse: 0x58d81294e6d0
Speicherleck 1 erzeugt an Adresse: 0x58d81294f6e0
Speicherleck 2 erzeugt an Adresse: 0x58d8129506f0
Speicherleck 3 erzeugt an Adresse: 0x58d812951700
Speicherleck 4 erzeugt an Adresse: 0x58d812952710

---------------------------------------------------------------------------------------------------------------

Fragen & Antworten:


1. Beschreiben Sie die Ausgabe des Programms. Was sagt sie über die Organisation des Speichers in Ihrem Betriebssystem aus?
Die Ausgabe zeigt deutlich die Speicherorganisation in deinem Linux-Betriebssystem:

Stack: Hohe Adressen (z. B. 0x7ffde8864a00), wächst nach oben (ungewöhnlich, typisch ist Abwärtswachstum).

Heap: Mittlere Adressen (z. B. 0x58d81294e2a0), dynamische Allokation, wächst nach oben.

Statische Variablen: Niedrige Adressen (z. B. 0x58d811a27010), feste Zuordnung beim Kompilieren.

Adressdifferenzen: Stack ist weit vom Heap/statischen Bereich entfernt (Milliarden Bytes), Heap und statischer Bereich liegen näher beieinander (~16 MB Differenz).


--------------------------------------------------

2. Erklären Sie, warum die Adressen der verschiedenen Variablentypen (Stack, Heap, statisch) 
in unterschiedlichen Speicherbereichen liegen. Die verschiedenen Variablentypen befinden sich 
aus folgenden Gründen in unterschiedlichen Speicherbereichen:

Statische Variablen:
Im Datensegment, lebenslang vorhanden.
Adressen beim Kompilieren festgelegt.

Heap:
Dynamisch zur Laufzeit (malloc), flexibel in Größe/Lebensdauer.
Fragmentierung möglich, wächst nach oben.

Stack:
Automatische Verwaltung (Funktionsaufrufe/lokale Variablen).
Schnelle Allokation durch Stack-Pointer.
Hohe Adressen für Isolation/Sicherheit.

Vorteile der Trennung:
Schutz vor Überschreibungen, optimierte Speichernutzung, effiziente Lebensdauer-Verwaltung.

------------------------------------------------

3. Welche Auswirkungen hat das absichtlich erzeugte Speicherleck? 
Wie könnte ein Betriebssystem mit solchen Situationen umgehen? Auswirkungen des Speicherlecks:

Auswirkungen:
Nicht freigegebener Speicher (z. B. 5 × 4 KB in der Ausgabe).
Bei Dauerbetrieb: Speichererschöpfung, Performanceverlust.

Betriebssystem-Massnahmen:
Automatische Bereinigung: Bei Prozessende wird gesamter Speicher freigegeben.
Ressourcenlimits: Tools wie ulimit setzen Speicherkontingente.
OOM-Killer (Linux): Beendet speicherintensive Prozesse.
Diagnose-Tools: Valgrind/Heap-Profiler erkennen Lecks.
Virtueller Speicher: Auslagern ungenutzter Seiten.

Prävention:
Manuelles free() in C/C++, Garbage Collection in Sprachen wie Java/Python.
