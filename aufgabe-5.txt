Speicheradressanalyse:
-----------------------
Stack-Variable: 0x7fff5f082418
Heap-Variable: 0x55cf541812a0
Statische Variable: 0x55cf530e8010

Adressunterschiede:
Stack -> Heap: 46385830302072 Bytes
Heap -> Static: 17404560 Bytes
Static -> Stack: 18446697687861844984 Bytes

Wachstumsrichtung des Stacks:
Der Stack wÃ¤chst nach oben.


1ï¸âƒ£ Organisation des Speichers im Betriebssystem
Das Programm zeigt:

Stack-Variable: Hoher Adressbereich (0x7fff...), genutzt fÃ¼r lokale Variablen.

Heap-Variable: Mittlerer Adressbereich (0x55cf...), genutzt fÃ¼r dynamische Allokierung.

Statische Variable: Ã„hnlich zum Heap, aber im Datensegment.

Fazit:

Der Stack wÃ¤chst nach oben.

Der Heap verwaltet dynamische Daten.

Statische Variablen sind im Datensegment, global verfÃ¼gbar.

ğŸ”¹ 2ï¸âƒ£ Warum unterschiedliche Speicherbereiche?
Jeder Bereich hat einen Zweck:

Stack: Schnell, temporÃ¤r, lokal.

Heap: Flexibel, dynamisch, aber langsamer.

Statisch: Global, bleibt wÃ¤hrend der gesamten Laufzeit.

ğŸ”¹ 3ï¸âƒ£ Auswirkungen des Speicherlecks
Im Code:

c
Copy
Edit
for (int i = 0; i < 5; i++) {
    malloc(sizeof(int)); // Kein free(), Speicherleck
}
Speicher wird belegt, aber nie freigegeben.

FÃ¼hrt zu Speicherverbrauch und mÃ¶glichen AbstÃ¼rzen bei vielen Lecks.

ğŸ”¹ 4ï¸âƒ£ Wie kann das OS das handhaben?
Garbage Collection: Automatische Bereinigung.

Paging und Swapping: Verlagerung auf die Festplatte.

Valgrind: Tool zur Erkennung von Speicherlecks.


