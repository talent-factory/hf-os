#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void analyze_memory_layout(int* stack_var, int* heap_var, int* static_var) {
    printf("Speicheradressanalyse:\n");
    printf("---------------------\n");
    printf("Stack-Variable: %p\n", (void*)stack_var);
    printf("Heap-Variable: %p\n", (void*)heap_var);
    printf("Statische Variable: %p\n", (void*)static_var);

    // Adressdifferenzen berechnen
    unsigned long stack_heap_diff = (unsigned long)stack_var - (unsigned long)heap_var;
    unsigned long stack_static_diff = (unsigned long)stack_var - (unsigned long)static_var;
    unsigned long heap_static_diff = (unsigned long)heap_var - (unsigned long)static_var;

    printf("\nAdressdifferenzen:\n");
    printf("Stack - Heap: %ld\n", stack_heap_diff);
    printf("Stack - Statisch: %ld\n", stack_static_diff);
    printf("Heap - Statisch: %ld\n", heap_static_diff);

    printf("\nWachstumsrichtungen:\n");

    int local1 = 1;
    int local2 = 2;

    if (&local2 > &local1)
        printf("Stack waechst nach oben (steigende Adressen)\n");
    else
        printf("Stack waechst nach unten (fallende Adressen)\n");

    printf("\n");
}

int main() {
    // Statische Variable
    static int static_variable = 100;

    // Stack-Variable
    int stack_variable = 200;

    // Heap-Variable
    int* heap_variable = (int*)malloc(sizeof(int));
    if (heap_variable == NULL) {
        printf("Fehler bei der Speicherzuweisung\n");
        return 1;
    }
    *heap_variable = 300;

    // Speicherlayout analysieren
    analyze_memory_layout(&stack_variable, heap_variable, &static_variable);

    // Speicherleck demonstrieren
    for (int i = 0; i < 5; i++) {
        int* leak = (int*)malloc(sizeof(int));
        *leak = i; // Verwendung zur Verhinderung von Optimierung
        // Hinweis: kein free(leak)
    }

    // Speicher freigeben
    free(heap_variable);

    return 0;
}

DDie Ausgabe des Programms zeigt exemplarisch, wie der virtuelle Speicher unter Ubuntu organisiert ist. Die Speicheradressen der drei untersuchten Variablen – einer lokalen Stack-Variable, einer dynamisch im Heap allokierten Variable und einer statischen Variable – liegen deutlich auseinander. Die Stack-Variable liegt im hohen Adressbereich (z. B. 0x7fff...), die Heap-Variable in einem mittleren Bereich (z. B. 0x5802...), und die statische Variable nochmals etwas tiefer (ebenfalls 0x5802..., aber mit einer deutlich geringeren Adresse). Das weist darauf hin, dass Betriebssysteme wie Linux den Speicher eines Prozesses segmentieren: statische Variablen werden im sogenannten Data-Segment abgelegt, Heap-Variablen im Heap-Segment, das bei Bedarf zur Laufzeit wächst, und lokale Variablen im Stack, der ebenfalls dynamisch, aber in umgekehrter Richtung verwaltet wird.

Bemerkenswert ist in deinem Fall, dass das Programm meldet, der Stack wachse „nach oben“, was bedeutet, dass die Adresse einer später deklarierten lokalen Variable höher ist als die einer früheren. Das widerspricht dem klassischen Verhalten, bei dem der Stack nach unten wächst – es kann jedoch an deiner Architektur, Compilereinstellungen oder einer Debug-Umgebung liegen. Es zeigt, dass solche Annahmen nicht absolut gelten, sondern vom Systemdesign abhängen.

Dass die drei Variablentypen in unterschiedlichen Speicherbereichen liegen, hat funktionale Gründe: Statische Variablen werden beim Start des Programms einmalig initialisiert und bleiben während der gesamten Laufzeit bestehen – sie benötigen daher einen dauerhaften, fest zugewiesenen Platz. Heap-Variablen werden bei Bedarf dynamisch mit malloc erzeugt und erfordern manuelle Verwaltung, da der Speicher sonst verloren geht. Stack-Variablen hingegen sind flüchtig und werden automatisch verwaltet – sie verschwinden, sobald der jeweilige Funktionskontext verlassen wird.

Das absichtlich erzeugte Speicherleck im Programm (fünfmal malloc ohne free) demonstriert eine typische Fehlerquelle in C-Programmen: Wenn Speicher reserviert, aber nicht freigegeben wird, und gleichzeitig keine Referenz darauf erhalten bleibt, kann dieser Speicher nicht mehr sinnvoll genutzt werden – er ist „verloren“. Bei kurzen Programmen ist das unkritisch, da das Betriebssystem nach Beendigung des Programms den Speicher zurückgibt. Bei lang laufenden Anwendungen, etwa Serverprozessen, kann sich dies jedoch akkumulieren und zu einem kritischen Ressourcenproblem führen. Betriebssysteme begegnen dem, indem sie Prozesse voneinander isolieren und ihren Speicher beim Beenden automatisch bereinigen. Für die Laufzeit selbst bieten Werkzeuge wie Valgrind die Möglichkeit, solche Lecks zu erkennen, was für professionelle Softwareentwicklung unerlässlich ist.

