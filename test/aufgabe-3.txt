Beschreibung der einzelnen Befehle und Konzepte

1. mkdir -p test/subdir && cd test
Erstellt einen Ordner 'test' mit Unterordner 'subdir', falls sie noch nicht existieren.
Wechselt danach ins 'test'-Verzeichnis.
Konzept: Arbeiten mit Ordnern und Navigation im Dateisystem.

2. echo "Inhalt-$(date +%s)" > original.txt
Schreibt den Text "Inhalt-" gefolgt vom aktuellen Zeitstempel in die Datei 'original.txt'.
Die Datei wird neu erstellt oder überschrieben.
Konzept: Erzeugen von Dateien und Schreiben von Inhalten.

3. ln -s original.txt symlink.txt
Erstellt einen symbolischen Link 'symlink.txt', der auf 'original.txt' zeigt.
Der Link speichert den Pfad zur Zieldatei.
Konzept: Symbolische Links (Verknüpfungen).

4. ln original.txt hardlink.txt
Erstellt einen Hardlink 'hardlink.txt', der direkt auf denselben Speicherbereich wie 'original.txt' zeigt.
Beide sind technisch dieselbe Datei mit zwei Namen.
Konzept: Hardlinks (gleicher Inode, gleicher Inhalt).

5. chmod 640 original.txt
Setzt die Rechte von 'original.txt' auf:
Besitzer: lesen, schreiben (rw-)
Gruppe: lesen (r--)
Andere: kein Zugriff (---)
Konzept: Dateirechte nach dem Unix/Linux-Rechtesystem.

6. touch -d "2 days ago" original.txt
Ändert das Datum der letzten Änderung von 'original.txt' auf "vor 2 Tagen".
Der Inhalt bleibt gleich.
Konzept: Arbeiten mit Zeitstempeln von Dateien.

7. ls -la
Zeigt eine ausführliche Liste aller Dateien, inklusive versteckter, mit Rechten, Datum usw.
Konzept: Anzeigen von Dateiinformationen.

Ausgabe des letzten Befehls:
insgesamt 20
drwxrwxr-x 3 vmadmin vmadmin 4096 Mai 10 08:31 .
drwxr-xr-x 4 vmadmin vmadmin 4096 Mai 10 08:30 ..
-rw-r----- 2 vmadmin vmadmin   18 Mai  9 06:31 hardlink.txt
-rw-r----- 2 vmadmin vmadmin   18 Mai  9 06:31 original.txt
drwxrwxr-x 2 vmadmin vmadmin 4096 Mai 10 08:30 subdir
lrwxrwxrwx 1 vmadmin vmadmin   12 Mai 10 08:31 symlink.txt -> original.txt

Analyse der Ausgabe:
1. Die Ausgabe zeigt alle Dateien und Ordner im aktuellen Verzeichnis mit vielen Infos dazu. Man sieht unter anderem den Dateinamen, wann die Datei zuletzt geändert wurde, wie groß sie ist und welche Rechte sie hat.
2. original.txt und hardlink.txt sind eigentlich die gleiche Datei mit zwei Namen. Beide haben den gleichen Inhalt, die gleichen Rechte, den gleichen Zeitstempel und teilen sich den gleichen Speicher. Das erkennt man auch daran, dass beide die gleiche Link-Anzahl 2 haben.
symlink.txt ist anders. Er zeigt nur auf den Namen original.txt, hat aber einen eigenen Speicherplatz. Wenn man ihn löscht, bleibt original.txt trotzdem da. Er hat auch einen anderen Zeitstempel und spezielle Rechte (lrwxrwxrwx), die immer bei symbolischen Links so aussehen.
3. riginal.txt und hardlink.txt teilen sich den gleichen Inode, weil sie beide direkt auf den gleichen Speicher im Dateisystem zeigen. Es ist also egal, welchen Namen man benutzt, der Inhalt ist der gleiche.
symlink.txt hat eine andere Inode-Nummer, weil er nur eine Art Verknüpfung ist. Er speichert nicht den Inhalt, sondern nur den Pfad zur echten Datei. Darum hat er auch eigene Metadaten und einen eigenen Zeitstempel.

die nächsten Befehlen:
Befehl 1: echo "Neuer Inhalt" > original.txt
Dieser Befehl überschreibt den Inhalt von original.txt mit dem Text "Neuer Inhalt".
Weil hardlink.txt der gleiche Inhalt ist (gleicher Speicher/Inode), wird auch hardlink.txt überschrieben.
symlink.txt zeigt weiterhin auf original.txt, also auch auf den neuen Inhalt.

Befehl 2: cat symlink.txt hardlink.txt
Dieser Befehl zeigt den Inhalt von symlink.txt und hardlink.txt an.
Beide zeigen jetzt den gleichen neuen Inhalt, also wird "Neuer Inhalt" zweimal ausgegeben.

Befehl 3: mv original.txt ../original.txt
Dieser Befehl verschiebt original.txt in den übergeordneten Ordner.
symlink.txt zeigt aber weiter auf den alten Pfad, wo original.txt jetzt nicht mehr existiert.
hardlink.txt bleibt erhalten, weil er den Speicher teilt und nicht den Pfad verwendet.

Befehl 4: cat symlink.txt hardlink.txt 2>&1
Dieser Befehl versucht erneut, den Inhalt von symlink.txt und hardlink.txt zu zeigen.
- symlink.txt gibt einen Fehler aus, weil die Zieldatei (original.txt) am alten Ort nicht mehr existiert.
- hardlink.txt zeigt weiterhin "Neuer Inhalt", weil es direkt auf den Speicher zeigt, una

Frage 1:
Ausgabe: 
cat symlink.txt hardlink.txt
Neuer Inhalt
Neuer Inhalt

cat symlink.txt hardlink.txt 2>&1
cat: symlink.txt: Datei oder Verzeichnis nicht gefunden
Neuer Inhalt

- hardlink.txt zeigt direkt auf den Speicher und bleibt immer gültig.
- symlink.txt zeigt nur auf den Dateinamen und funktioniert nur, solange der Pfad existiert

Welche Auswirkungen haben die Befehle auf die Inode-Tabelle?

- original.txt und hardlink.txt teilen sich den gleichen Inode, weil sie beide auf denselben Speicher zeigen.
- symlink.txt bekommt einen eigenen Inode, da er nur einen Pfad speichert und nicht den Inhalt selbst.
- Beim Verschieben von original.txt bleibt der Inode von hardlink.txt erhalten. Der Inode von symlink.txt bleibt ebenfalls bestehen, aber der gespeicherte Pfad zeigt ins Leere.


Wie unterscheidet sich das Verhalten von symbolischen und harten Links in diesem Szenario?

- Harte Links wie hardlink.txt bleiben funktionsfähig, auch wenn original.txt verschoben wird, weil sie direkt mit dem Speicher verbunden sind.
- Symbolische Links wie symlink.txt funktionieren nur, wenn das Ziel noch am gleichen Ort liegt. Wird original.txt verschoben, zeigt der symlink ins Leere und es kommt zu Fehlern.


Welche Fehler könnten auftreten und warum?

- Bei symlink.txt kommt ein Fehler „Datei oder Verzeichnis nicht gefunden“, wenn das Ziel verschoben oder gelöscht wurde, weil der Link nur den Pfad speichert.
- Bei hardlink.txt tritt kein Fehler auf, weil er unabhängig vom Dateinamen direkt auf die Daten zeigt.

Bonus Frage:
- Ich würde sagen, dass harte Links nicht über verschiedene Dateisysteme funktionieren, weil sie nur im gleichen Dateisystem erlaubt sind. Symbolische Links funktionieren aber auch über mehrere Dateisysteme, weil sie nur den Pfad merken. Trotzdem kann ein symbolischer Link kaputtgehen, wenn das Ziel verschoben oder gelöscht wird.

